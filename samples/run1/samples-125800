======== SAMPLE 1 ========
            let e1 := mkP t1 in
             let e2 := mkP t2 in
             Ring_polynom.PEadd e1 e2
       | rmul ?t1 ?t2 =>
           fun _ =>
             let e1 := mkP t1 in
             let e2 := mkP t2 in
             Ring_polynom.PEmul e1 e2
       | rsub ?t1 ?t2 =>
           fun _ =>
             let e1 := mkP t1 in
             let e2 := mkP t2 in
             Ring_polynom.PEsub e1 e2
       | ropp ?t1 =>
           fun _ => let e1 := mkP t1 in
                     Ring_polynom.PEopp e1
       | rpow ?t1 ?n =>
           match CstPow n with
           | NotConstant =>
               fun _ => let p := Find_at t fv in
                         Ring_polynom.PEX C p
           | ?c => fun _ => let e1 := mkP t1 in
                             Ring_polynom.PEpow e1 c
           end
       | _ => fun _ => let p := Find_at t fv in
                       Ring_polynom.PEX C p
       end
   | ?c => fun _ => Ring_polynom.PEc c
   end
  in
  f ltac:(())


TcDebug (15) > 
Goal:
  
  R : Type
  rO : R
  rI : R
  radd : R -> R -> R
  rmul : R -> R -> R
  rsub : R -> R -> R
  ropp : R -> R
  rdiv : R -> R -> R
  rinv : R -> R
  req : R -> R -> Prop
  Rsth : Equivalence req
  Reqe : ring_eq_ext radd rmul ropp req
  SRinv_ext : forall p q : R, p == q -> / p == / q
  AFth : almost_field_theory
  ARth := AF_AR AFth : almost_ring_theory 0 1 radd rmul rsub ropp req
  rI_neq_rO := AF_1_neq_0 AFth : ~ 1 == 0
  rdiv_def := AFdiv_def AFth : forall p q : R, p / q == p * / q
  rinv_l := AFinv_l AFth : forall p : R, ~ p == 0 -> / p * p == 1
  eq_trans := Seq_trans R req Rsth
           : forall x y z : R, x == y -> y == z -> x == z
  eq_sym := Seq_sym R req Rsth : forall x y : R, x == y -> y == x
  eq_refl := Seq_refl R req Rsth : forall x : R, x == x
  radd_0_l := ARadd_0_l ARth : forall x : R, 0 + x == x

