======== SAMPLE 1 ========
mula) l * FSetDec (add_p ex mul cO cT cT) mul_p ev' (FEX C p) -> negb "5" = true
  H1 : bool
  H2 : fsetdec
  ============================
   (add cO (fst p) (fst (fst p)) = negb (fst (fst p)))


Debug: Going to execute:
rewrite negb_iff_l


TcDebug (0) > 
Debug: Evaluated term: negb_iff_l

Debug: Evaluated term: negb_iff_l

Goal:
  
  R : Type
  rO : R
  rI : R
  radd : R -> R -> R
  rmul : R -> R -> R
  rsub : R -> R -> R
  ropp : R -> R
  req : R -> R -> Prop
  Rsth : Equivalence req
  Reqe : ring_eq_ext radd rmul ropp req
  ARth : almost_ring_theory 0 1 radd rmul rsub ropp req
  C : Type
  cO : C
  cI : C
  cadd : C -> C -> C
  cmul : C -> C -> C
  csub : C -> C -> C
  copp : C -> C
  ceqb : C -> C -> bool
  phi : C -> R
  CRmorph : ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp
              ceqb phi
  Cpow : Type
  Cp_phi : N -> Cpow
  rpow : R -> Cpow -> R
  pow_th : power_theory 1 rmul req Cp_phi rpow
  P'1 : Pol
  p : positive
  P'2 : Pol
  IHP'1 : forall (P : Pol) (l : Env R), (P -- P'1) @ l == P @ l - P'1 @ l
  IHP'2 : forall (P : Pol) (l : Env R), (P -- P'2) @ l == P @ l - P'2 @ l
  p0 : positive
  P : Pol
  l : Env R
  He : p0 < p
  ============================
   ((p +-- P'1) @ (tail l) == (p +-- P'1) @ (tail l) + [p] @ (tail l))


Debug: Going to execute:
assert X2; [ exact (id0 id1) | clear id0 ]


TcDebug (1) > 
Goal:
  
  R : Type
  rO : R
  rI : R
  radd : R -> R -> R
  rmul : R -> R -> R
  rsub : R -> R -> R
  ropp : R -> R
  req : R -> R -> Prop
  Rsth : Equivalence req
  Reqe : ring_eq_ext radd rmul ropp req
  ARth : almost_ring_theory 0 1 radd rmul rsub ropp req
  C : Type
  cO : C
  cI : C
  cadd : C -> C -> C
  cmul : C -> C -> C
  csub : C -> C -> C
  copp : C -> C
  ceqb : C -> C -> bool
  phi : C -> R
  CRmorph : ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp
              ceqb phi
  Cpow : Type
  Cp_phi : N -> Cpow
  rpow : R -> Cpow -> R
  pow_th : power_theory 1 rmul req Cp_phi rpow
  P'1 : Pol
  p : positive
  P'2 : Pol
  IHP'1 : forall (P : Pol) (l : Env R), (P -- P'1) @ l == P @ l - P'1 @ l
  IHP'2 : forall (P : Pol) (l : Env
