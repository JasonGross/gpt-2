======== SAMPLE 1 ========
Se (Ring_polynom.PEX Q 1)
                 (Ring_polynom.PEadd (Ring_polynom.PEX Q 1)
                     (Ring_polynom.PEc 0))) 1
                   (Ring_polynom.PEX Q (Ring_polynom.PEc 1)))
  res : list Q
  res_eq : Ring_polynom.mk_monpol_list 0 1 Qplus Qmult Qminus Qopp Qeq_bool
             (triv_div 0 1 Qeq_bool) list_hyp = res
  res0 := {|
          num := Ring_polynom.PExpr Q 2;
         denum := Ring_polynom.PEmul (Ring_polynom.PEX Q 1)
          condition := nil |} : linear Q
  res_eq0 : Fnorm 0 1 Qplus Qmult Qminus Qopp Qeq_bool
             (FEadd (FEsub (FEX Q 1) (FEX Q 2)) (FEX Q 1)) = res0
  res1 := {|
         num := Ring_polynom.PEmul (Ring_polynom.PEX Q 1)
                  (Ring_polynom.PEX Q (Ring_polynom.PEc 0)))
                  (Ring_polynom.FEX Q (Ring_polynom.PEX Q (Ring_polynom.PEc 0))) = res1
  ============================
   (PCond 0 1 Qplus Qmult Qminus Qopp Qdiv 0 1 Qeq_bool
      (IDphi (R:=Q)) Z.of_N Qpower (Qpower_positive a n :: nil)
      (Qpower_positive a (Pos.to_nat p) :: 1 # p) ==
     Qpower_positive a n * a # p)


Debug: Going to execute:
<ltac_plugin::clear@0> $1


TcDebug (0) > 
Goal:
  
  a : Q
  p : positive
  H : (Z.pos p + 0)%Z <> 0%Z
  X : a == 0
  list_hyp := nil : list (Ring_polynom.PExpr Q * Ring_polynom.PExpr Q)
  list_hyp_norm := nil : list (Q * Ring_polynom.Mon * Ring_polynom.Pol Q)
  ring_lemma : forall (pe : Ring_polynom.PExpr Q) (npe : Ring_polynom.Pol Q),
               Ring_polynom.norm_subst 0 1 Qplus Qmult Qminus Qopp Qeq_bool
                 (triv_div 0 1 Qeq_bool) ring_subst_niter list_hyp_norm pe =
               npe ->
               Ring_polynom.PEeval 0 1 Qplus Qmult Qminus Qopp 
                 (IDphi (R:=Q)) Z.of_N Qpower
                 (Qpower_positive a n :: nil) pe ==
                Ring_polynom.Pphi_pow 0 1 Qplus Qmult Qminus Qopp 0 1 Qeq_bool
                  (IDphi (R:=Q)) Z.of_N Qpower (get_sign_None (C:=Q))
                  (Qpower
