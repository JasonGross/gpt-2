======== SAMPLE 1 ========
) (x, e) = true -> (if (g true) = g false) -> false = true)


Debug: Going to execute:
<ltac_plugin::intro@0>


TcDebug (1) > 
Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Debug:
Going to execute:
match goal with
| |- ?X1 -> ?X2 => intro
| |- ~ _ => unfold not at 1; intro
end


TcDebug (0) > 
Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Debug: Going to execute:
intro


TcDebug (1) > 
Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Debug: Going to execute:
<ltac_plugin::intro@0>


TcDebug (1) > 
Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  H0 : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of_nat n
  ============================
   (Z.of_nat n < 0 \/ subset n (x ^ n) = subset (x ^ n) (x ^ n - x * s))


Goal:
  
  f := fun n : Z => Z.of_nat n + 1 <-> (Z.of_nat n + 1 < 0)%nat
  x : Z
  H : 0 < Z.of
