======== SAMPLE 1 ========
 match reverse goal with
      | id:(?X1 -> ?X2) -> ?X3
        |- _ =>
            cut X3;
             [ intro; clear id; t_tauto_intuit
             | cut (X1 -> X2);
                 [ exact
                 id
                 | generalize (fun y : X2 => id (fun x : X1 => y)); intro;
                    clear id; (solve [ t_tauto_intuit ]) ] ]
      | id:~ ?X1 -> ?X3
        |- _ =>
            cut X3;
             [ intro; clear id; t_tauto_intuit
             | cut (~ X1);
                [ exact id | clear id; intro; (solve [ t_tauto_intuit ]) ] ]
      | |- ?X1 =>
            <Coq.Init.Tauto.is_disj> flags X1; (solve
             [ left; t_tauto_intuit | right; t_tauto_intuit ])
      end ||
        match goal with
        | |- _ -> _ => intro; t_tauto_intuit
        | |- _ => t_reduce; t_solver
        end || t_solver
  in
  t_tauto_intuit


TcDebug (3) > 
Goal:
  
  ll : tree
  lx : X.t
  lr : tree
  x : elt
  rl : tree
  rx : X.t
  rr : tree
  a : tree
  y : X.t
  b : tree
  H : InT x a -> InT x lr \/ InT x rl
  H5 : InT x b
  H4 : InT x rl
  H2 : X.eq x y
  H1 : InT x lr
  H0 : InT x a
  ============================
   ((InT x ll \/ X.eq x lx \/ InT x lr) \/ InT x rl \/ X.eq x rx \/ InT x rr)


Debug: Going to execute:
fun => <tauto_plugin::reduction_not_iff@0>


TcDebug (3) > 
Goal:
  
  ll : tree
  lx : X.t
  lr : tree
  x : elt
  rl : tree
  rx : X.t
  rr : tree
  a : tree
  y : X.t
  b : tree
  H : InT x a -> InT x lr \/ InT x rl
  H5 : InT x b
  H4 : InT x rl
  H2 : X.eq x y
  H1 : InT x lr
  H0 : InT x a
  ============================
   ((InT x ll \/ X.eq x lx \/ InT x lr) \/ InT x rl \/ X.eq x rx \/ InT x rr)


Debug:
Going to execute:
let rec t_tauto_intuit :=
 <Coq.Init.Tauto.simplif> flags;
  <Coq.Init.Tauto.axioms> flags ||
    match reverse goal with
    | id:(?X1 -> ?X2) -> ?X3
 
