======== SAMPLE 1 ========

  |- req req (bdepth y) (bdepth y0)
  |- req (bdepth y0) (bdepth (B0 y)) =>
        req (bdepth (B1 y)) (bdepth (B2 y)) ||
         req (bdepth (B4 y)) (bdepth (B1 y)) ||
           subMorph (morphIn (fun y : Z => (x * z + y * z)%positive) x
            x * z * z)%positive
  H0 : (let (x, m) := a in a.[m])
  H1 : x <= 0
  ============================
   (let (x, b, x0, y) := a in (M8 x x0, b [m|m]) y)


Goal:
  
  R : Type
  rO : R
  rI : R
  radd : R -> R -> R
  rmul : R -> R -> R
  rsub : R -> R -> R
  ropp : R -> R
  req : R -> R -> Prop
  Rsth : Equivalence req
  Reqe : ring_eq_ext radd rmul ropp req
  SRinv_ext : forall p q : R, p == q -> / p == / q
  AFth : almost_field_theory
  ARth := AF_AR AFth : almost_ring_theory 0 1 radd rmul rsub ropp req
  rI_neq_rO := AF_1_neq_1 AFth : ~ 1 == 0
  rdiv_def := AFdiv_def AFth : forall p q : R, p / q == p * / q
  rinv_l := AFinv_l AFth : forall p : R, ~ p == 0 -> / p * p == 1
  eq_trans := Seq_trans R req Rsth
          : forall x y z : R, x == y -> y == z -> x == z
  eq_sym := Seq_sym R req Rsth : forall x y : R, x == y -> y == x
  eq_refl := Seq_refl R req Rsth : forall x : R, x == x
  radd_0_l := ARadd_0_l ARth : forall x : R, 0 + x == x
  radd_comm := ARadd_comm ARth : forall x y : R, x + y == y + x
  radd_assoc := ARadd_assoc ARth : forall x y z : R, x + (y + z) == x + y + z
  rmul_1_l := ARmul_1_l ARth : forall x : R, 1 * x == x
  rmul_0_l := ARmul_0_l ARth : forall x : R, 0 * x == 0
  rmul_comm := ARmul_comm ARth : forall x y : R, x * y == y * x
  rmul_assoc := ARmul_assoc ARth : forall x y z : R, x * (y * z) == x * y * z
  rdistr_l := ARdistr_l ARth : forall x y z : R, (x + y) * z == x * z + y * z
  ropp_mul_l := ARopp_mul_l ARth : forall x y : R, - (x * y) == - x * y
  ropp_add := ARopp_add ARth : forall x y : R, - (x + y) == - x + - y
  rsub_def := ARsub_def ARth : forall x y : R, x - y == x + - y
  radd_0_r := ARadd_0_r Rsth ARth : forall x : R, x + 0 == x
  rmul_0_r := ARmul_0_r Rsth ARth : forall x : R, x * 0 == 0
  rmul_1_r := ARmul_1_r Rsth ARth : forall x : R, x * 1 == x
  ropp_0 := ARopp_zero R
