======== SAMPLE 1 ========
        | a :: _ => let z := fresh "z" in
                                               (d' * 10 ^ usize
                                 (xn 4%nat :: nil)%list
                                (xn 13%nat :: nil)%list
                             (xn 5%nat :: nil)%list
                           (xn 8%nat :: nil)%list
                           ((xn2 + 1)%nat :: nil)%list
                           (xn5 + 1)%nat :: nil)%list)
      (xn8 + 1 + 1 == xn - 2%nat)


Debug:
Going to execute:
fun x z =>
  let := fresh "z" in
  (rename a into z)%list;
   repeat
    (match reverse goal with
     | id:?X1
       |- _ =>
           <Coq.Init.Tauto.is_conj> flags X1; elim id; do 2 intro; clear id
     | id:_ <-> _ |- _ => elim id; do 2 intro; clear id
     | id:~ _ |- _ => red in id
     | id:?X1
       |- _ => <Coq.Init.Tauto.is_disj> flags X1; elim id; intro; clear id
     | id0:?X1 -> ?X2, id1:?X1
       |- _ => assert X2; [ exact (id0 id1) | clear id0 ]
     | id:?X1 -> ?X2
       |- _ =>
           <Coq.Init.Tauto.is_unit_or_eq> flags X1; cut X2;
           [ intro; clear id | cut X1; [ exact id | constructor 1; fail ] ]
     | id:?X1 -> ?X2
       |- _ => <Coq.Init.Tauto.flatten_contravariant_conj> flags X1 X2 id
     | id:?X1 <-> ?X2 -> ?X3
       |- _ =>
           assert ((X1 -> X2) -> (X2 -> X1) -> X3) by
           (do 2 intro; apply id; split; assumption); clear id
     | id:?X1 -> ?X2
       |- _ => <Coq.Init.Tauto.flatten_contravariant_disj> flags X1 X2 id
     | |- ?X1 => <Coq.Init.Tauto.is_conj> flags X1; split
     | |- _ <-> _ => split
     | |- ~ _ => red
     end; <Coq.Init.Tauto.not_dep_intros>)


TcDebug (2) > 
Goal:
  
  xn : nat -> Q
  limx : QCauchySeq xn Pos.to_nat
  n : positive
  list_hyp := nil : list (Ring_polynom.PExpr
