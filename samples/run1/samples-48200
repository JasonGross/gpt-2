======== SAMPLE 1 ========
 | true = true
  FSetDecideAuxiliary.imp_rt_rec =>
                     FSetDecideAuxiliary.norm_subst 0 1 Z.add Z.mul Z.sub Z.opp Zeq_bool
                        Z.quotrem ring_subst_niter list_hyp_norm 
               | ring_subst_niter list_hyp_norm 
               | res_eq (x :: list_hyp_norm x) nil
              end
  res := Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0)
      : Ring_polynom.Pol Z
  res_eq : Ring_polynom.norm_subst 0 1 Z.add Z.mul Z.sub Z.opp Zeq_bool
              Z.quotrem ring_subst_niter list_hyp_norm 
              (Ring_polynom.PEX Z 1) = res
  thm : Ring_polynom.PEeval 0 1 Z.add Z.mul Z.sub Z.opp 
          (IDphi (R:=Z)) Z.of_N Z.pow
          (z1 :: t1 :: Z.pos z2 :: Z.pos t2 :: Z.pos x2 :: Z.pos y2 :: nil)
          (Ring_polynom.PEX Z 1) =
        Ring_polynom.Pphi_pow 0 1 Z.add Z.mul Z.sub Z.opp 0 1 Zeq_bool
          (IDphi (R:=Z)) Z.of_N Z.pow get_signZ
          (z1 :: t1 :: Z.pos z2 :: Z.pos t2 :: Z.pos x2 :: Z.pos y2 :: nil)
          res)%CR_MSet
  res0 := Ring_polynom.Pinj 1
            (Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0))
       : Ring_polynom.Pol Z
  res_eq0 : Ring_polynom.norm_subst 0 1 Z.add Z.mul Z.sub Z.opp Zeq_bool
              Z.quotrem ring_subst_niter list_hyp_norm
              (Ring_polynom.PEX Z 2) = res0
  thm0 : Ring_polynom.PEeval 0 1 Z.add Z.mul Z.sub Z.opp 
           (IDphi (R:=Z)) Z.of_N Z.pow
           (z1 :: t1 :: Z.pos z2 :: Z.pos t2 :: Z.pos x2 :: Z.pos y2 :: nil)
           (Ring_polynom.PEX Z 2) =
         Ring_polynom.Pphi_pow 0 1 Z.add Z.mul Z.sub Z.opp 0 1 Zeq_bool
           (IDphi (R:=Z)) Z.of_N Z.pow get_signZ (z1 :: t1 :: Z.pos z2 :: Z.pos t2 :: Z.pos x2 :: Z.pos y2 :: nil)
          res0)%CR_MSet
  res1 := Ring_polynom.Pinj 3
           (Ring_polynom.PX (
