======== SAMPLE 1 ========
uit ])
   end ||
     match goal with
     | |- _ -> _ => intro; t_tauto_intuit
     | |- _ => t_reduce; t_solver
     end || t_solver


TcDebug (6) > 
Goal:
  
  x1 : O1.t
  x2 : O2.t
  f1 : A -> Type
  f2 : A -> Type
  f3 : A -> Type
  l : list A
  l0 : P x1
  H : InA x2 l1
  H0 : InA x3 l2
  ============================
   (InA x2 l1)


Debug: Going to execute:
<Coq.Init.Tauto.axioms> flags


TcDebug (6) > 
Goal:
  
  x1 : O1.t
  x2 : O2.t
  f1 : A -> Type
  f2 : A -> Type
  f3 : A -> Type
  l : list A
  l0 : P x1
  H : InA x2 l1
  H0 : InA x3 l2
  ============================
   (InA x2 l1)


Debug:
Going to execute:
fun flags solver =>
  <Coq.Init.Tauto.tauto_intuit> flags
   ltac:(<Coq.Init.Tauto.reduction_not_iff>) solver


TcDebug (7) > 
Goal:
  
  x1 : O1.t
  x2 : O2.t
  f1 : A -> Type
  f2 : A -> Type
  f3 : A -> Type
  l : list A
  l0 : P x1
  H : InA x2 l1
  H0 : InA x3 l2
  ============================
   (InA x2 l1)


Debug:
Going to execute:
let rec t_tauto_intuit :=
 <Coq.Init.Tauto.tauto_intuit> flags ltac:(<Coq.Init.Tauto.reduction_not_iff>)
 solver


TcDebug (7) > 
Goal:
  
  x1 : O1.t
  x2 : O2.t
  f1 : A -> Type
  f2 : A -> Type
  f3 : A -> Type
  l : list A
  l0 : P x1
  H : InA x2 l1
  H0 : InA x3 l2
  ============================
   (InA x2 l1)


Debug:
Going to execute:
fun flags t_tauto_intuit =>
  <Coq.Init.Tauto.tauto_intuit> flags ||
    <Coq.Init.Tauto.tauto_intuit> flags ||
      match reverse goal with
      | id:(?X1 -> ?X2) -> ?X3
       |- _ =>
           cut X3;
            [ intro; clear id; t_tauto_intuit
            | cut (X1 -> X2);
               [ exact
               id
               | generalize (fun y : X2 => id (fun x : X1 => y)); intro;
                  clear id; (solve [ t_tauto_intuit ]) ] ]
      | id:~ ?X1 -> ?X3
       |- _ =>
           cut X3;
            [ intro; clear id; t_tauto_intuit
            | cut (~ X1);
               [ exact id |
