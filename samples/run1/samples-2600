======== SAMPLE 1 ========
) : t elt
  l1 : t elt
  r1 : t elt
  _x : key
  l2' : t elt'
  r2' : t elt''
  m2 : t elt'
  E.eq x1 r1 ->
        InT y l1 \/ InT y (rev (x1 :: l2') -> t elt') <->
         InT y r1 \/ InT y (rev (x2 :: l2') -> t elt')
  IHt1 : forall y : key,
         InT y (add x1 r1 -> ~ InT y (map2_opt_le r1 (mapLeaf l1 x1 d1 r1)) x1 ->
         InT y r1 \/ InT y (rev l1) \/ InT y (map2_opt_le r1 (mapLeaf l1 x1 d1 r1))
  y : key
  H4 : InT y l1
  H5 : InT y l2'
  H6 : InT y r2'
  H7 : InT y r2'
  H0 : InT y r2'
  H8 : InT y r1
  H : InT y r2'
  ============================
   (InT y r1 \/ X.lt y x1 \/ InT y l1 -> X.lt y x1)


Debug: Going to execute:
<tauto_plugin::is_disj@0>


TcDebug (2) > 
Debug: Level 2: evaluation returns
<tactic closure>


Goal:
  
  elt : Type
  elt' : Type
  elt'' : Type
  f0 : key -> option elt -> option elt' -> option elt''
  f : key -> elt -> option elt' -> option elt''
  mapl : t elt -> t elt''
  mapr : t elt' -> t elt''
  f0_f : forall (x : key) (d : elt) (o : option elt'),
          f x d o = f0 x (Some d) o
  mapl_bst : forall m : t elt, bst m -> bst (mapl m)
  mapr_bst : forall m' : t elt', bst m' -> bst (mapr m')
  mapl_f0 : forall (x : X.t) (m : t elt),
             bst m ->
             find x (mapl m) =
             match find x m with
             | "lt, x" => find x (mapr m')
             | _" => find x (mapr m')
             end
  mapr_f0 : forall (x : X.t) (m' : t elt'),
             bst m' ->
             find x (mapr m') =
             match find x m' with
             | "MX" => find x (mapr m')
              | _" => find x (mapr m')
             end
  f0_compat : forall (x x' : X.t) (o : option elt) (o' : option elt'),
               X.eq x x' -> f0 x o o' = f0 x' o o'
  l1 : t elt
  x1 : key
  d1 : elt
  r1 : t elt
  _x : key
  l2' : t elt'
  r2' : t elt
