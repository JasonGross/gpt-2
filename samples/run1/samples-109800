======== SAMPLE 1 ========
) + 1) ^ 2
  s := iter2_sqrt size (λ _ _ j : int, j) ih il max_int : int
  Hs1 : φ (s) ^ 2 <= [||WW ih il||]
  Hs2 : [||WW ih il||] < (φ (s) + 1) ^ 2
  ih1 : int
  il1 : int
  Hihl1 : φ (s) * φ (s) = φ (ih1) * wB + φ (il1)
  il2 : int
  Hil2 : φ (il2) = φ (il) - φ (il1)
  Heq : φ (ih1) < φ (ih)
  H2 : φ (ih1) + 1 = φ (ih)
  ============================
   ((φ (ih1) + 1) * wB + φ (il) - (φ (ih1) * wB + φ (il1)) =
    φ (ih1) * wB + φ (il1) + (wB + (φ (il) - φ (il1))))


Debug: Going to execute:
find 1%positive l


TcDebug (24) > 
Goal:
  
  ih : int
  il : int
  Hih : wB / 4 <= φ (ih)
  Hbin : ∀ s : Z, s * s + 2 * s + 1 = (s + 1) ^ 2
  Hb : 0 <= wB
  Hi2 : [||WW ih il||] < (φ (max_int) + 1) ^ 2
  s := iter2_sqrt size (λ _ _ j : int, j) ih il max_int : int
  Hs1 : φ (s) ^ 2 <= [||WW ih il||]
  Hs2 : [||WW ih il||] < (φ (s) + 1) ^ 2
  ih1 : int
  il1 : int
  Hihl1 : φ (s) * φ (s) = φ (ih1) * wB + φ (il1)
  il2 : int
  Hil2 : φ (il2) = φ (il) - φ (il1)
  Heq : φ (ih1) < φ (ih)
  H2 : φ (ih1) + 1 = φ (ih)
  ============================
   ((φ (ih1) + 1) * wB + φ (il) - (φ (ih1) * wB + φ (il1)) =
    φ (ih1) * wB + φ (il1) + (wB + (φ (il) - φ (il1))))


Debug:
Going to execute:
fun n l =>
  match l with
  | nil => fail 1
  | (?x :: ?l)%list =>
      fun _ =>
        let e1 := mkP t1 in
        let e2 := mkP t2 in
        Ring_polynom.PEadd e1 e2
  | (?x :: ?l)%list =>
       fun _ =>
        let e1 := mkP t1 in
        let e2 := mkP t2 in
        Ring_polynom.PEsub e1 e2
  | (?x :: ?l)%list =>
       fun _ =>
        let e1 := mkP t1 in
        let e2 := mkP t2 in
        Ring_polynom.PEadd e1 e2
  | (?x :: ?l)%list =>
       fun _ =>
        let e1 := mkP t1 in
        let e2 := mkP t2 in
        Ring_polynom.PEsub e1 e2
  | (?x :: ?l)%list =>
    
