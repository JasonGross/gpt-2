======== SAMPLE 1 ========
 e2 : PExpr C
  add : R -> R -> R
  mul : R -> R -> R
  sub : R -> R -> R
  opp : R -> R
  ring_eq : R -> R -> Prop
  Ro : Ring_ops
  Cr : Ring
  ring2 : R
  ring3 : R
  add0 : R -> R -> R
  mul0 : R -> R -> R
  sub0 : R -> R -> R
  opp0 : R -> R
  ring_eq0 : R -> R -> Prop
  Ro0 : Ring_ops
  Rr : Ring
  Rh0 : Bracket C R
  Rh :interp_phi (p - p1) phi
  phi' : t
  phi'0 : t
  H :recursion := let ph := fresh "pred_ext" in
            match phi' with
            | Ssr => Rintent (fdigits phi')
            | _ => fun _ => TFV t1 fv
            end
         | _ => fun _ => TFV t1 fv
         end
   | _ => fun _ => fv
   end
  in
  let rec f :=
   match Cst t with
   | NotConstant =>
       match t with
       | rO => fun _ => fv
       | rI => fun _ => fv
       | add ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t1 fv)
       | mul ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t1 fv)
       | sub ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t1 fv)
       | opp ?t1 => fun _ => TFV t1 fv
       | pow ?t1 ?n =>
           match CstPow n with
           | NotConstant => fun _ => AddFvTail t fv
           | _ => fun _ => TFV t1 fv
           end
       | _ => fun _ => AddFvTail t fv
       end
   | _ => fun _ => fv
   end
  in
  f ltac:(())


TcDebug (24) > 
Goal:
  
  R : Type
  rO : R
  rI : R
  radd : R -> R -> R
  rmul : R -> R -> R
  rsub : R -> R -> R
  ropp : R -> R
  rdiv : R -> R -> R
  rinv : R -> R
  req : R -> R -> Prop
  Rsth : Equivalence req
  Reqe : ring_eq_ext radd rmul ropp req
  SRinv_ext : forall p q : R, p == q -> / p == / q
  AFth : almost_field_theory
  ARth := AF_AR AFth : almost_ring_theory 0 1 radd rmul rsub ropp req
  rI_neq_rO := AF_1_neq_0 AFth : ~ 1 == 0
  rdiv_def := AFdiv_def AFth : forall p q : R, p / q == p * / q
  rinv_l := AFinv_l AFth : forall p : R, ~ p == 0 -> / p * p == 1
  eq_trans := Seq_trans R req Rsth
          : forall x y z : R, x == y -> y == z -> x == z
  eq_sym := Seq_sym R req Rsth : forall x y : R, x == y -> y == x
  eq_refl := Seq_refl R req
