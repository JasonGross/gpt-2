======== SAMPLE 1 ========
 
  ih : int
  il : int
  Hih : wB / 4 < φ (ih)
  Hbin : ∀ s : Z, s * s + 2 * s + 1 * s + 2 * s + 1 * s
  Hb : 0 <= wB
  Hi2 : [||WW ih il||] < (φ (max_int) + 1) ^ 2
  s := iter2_sqrt size (λ _ _ j : int, j) ih il max_int : int
  Hs1 : φ (s) ^ 2 <= [||WW ih il||]
  Hs2 : [||WW ih il||] < (φ (s) + 1) ^ 2
  ih1 : int
  il1 : int
  Hihl1 : φ (s) * φ (s) = φ (ih1) * wB + φ (il1)
  il2 : int
  Hil2 : -1 * wB + φ (il2) = φ (il) - φ (il1)
  Hsih : φ (ih - 1) = φ (ih) - 1
  Heq : ¬ φ (ih1) < φ (ih) - 1
  H1 : φ (ih) - 1 = φ (ih1)
  ============================
   (wB + φ (il2) - φ (il1) + (wB + φ (il1)) - wB + (φ (il) - φ (il1)))%int63 =
    (φ (ih1) + 1) + (φ (il) - φ (il1)) - wB + (φ (il) - φ (il1)))


Debug:
Going to execute:
let rec t_tauto_intuit :=
 <Coq.Init.Tauto.simplif> flags;
  <Coq.Init.Tauto.axioms> flags ||
    match reverse goal with
    | id:(?X1 -> ?X2) -> ?X3
      |- _ =>
          cut X3;
           [ intro; clear id; t_tauto_intuit
           | cut (X1 -> X2);
              [ exact
              id
              | generalize (fun y : X2 => id (fun x : X1 => y)); intro;
                  clear id; (solve [ t_tauto_intuit ]) ] ]
    | id:~ ?X1 -> ?X3
     |- _ =>
         cut X3;
          [ intro; clear id; t_tauto_intuit
          | cut (~ X1);
             [ exact id | clear id; intro; (solve [ t_tauto_intuit ]) ] ]
   | |- ?X1 =>
         <Coq.Init.Tauto.is_disj> flags X1; (solve
          [ left; t_tauto_intuit | right; t_tauto_intuit ])
   end ||
     match goal with
     | |- _ -> _ => intro; t_tauto_intuit
    | |- _ => t_reduce; t_solver
    end || t_solver


TcDebug (2) > 
Goal:
  
  ih : int
  il : int
  Hih : wB / 4 < φ (ih)
  Hbin : ∀ s : Z, s * s + 2 * s + 1 * s + 2 * s + 1 * s
  Hb : 0 <= wB
  Hi2 : [||WW ih il||] < (φ (max_int) + 1) ^ 2
  s
