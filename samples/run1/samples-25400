======== SAMPLE 1 ========
   (1) < l')


Debug: Going to execute:
<ltac_plugin::clear@0> $1


TcDebug (0) > 
Goal:
  
  E : Type
  P : elt -> bool
  P' : Proper (E.eq ==> Proper) P'
  P2L : Pol -> Prop
  P'1 : Pol -> Pol
  P2R : Pol
  P2R_of_positive : P2, P2, P'2, P2, P'2, P2, (P3, P3)
  P1 : Pol
  l : list (X.t * P')
  y : elt
  Padd_P : Psub P1 x (PX.eq_PX Padd P1 P2) l
  P2_0 : Psub P2 X.eq X P2
  H : P3 = P2)
  H0 : (P3, P') -> False
  H0 : P2 -> False
  H1 : forall a : elt,
        In a (PX.eq_bool P'1 P'2 eqx (Pexpr P2_0 P'2)) -> PimpX M) H0 (In a (Pexpr P2_0 P'2)) -> PimpX M)) l
  ============================
   (1) < l')


Debug: Going to execute:
clear H


TcDebug (0) > 
Goal:
  
  E : Type
  P : elt -> bool
  P' : Proper (E.eq ==> Proper) P'
  P2L : Pol -> Prop
  P'1 : Pol -> Pol
  P2R : Pol
  P2R_of_positive : P2, P2, P'2, P2, P2, P1, P'2, P2, P1, P'2, P'2, (P3, P3)
  P1 : Pol
  l : list (X.t * P')
  y : elt
  Padd_P : Psub P1 x (PX.eq_PX Padd P2 P2) l
  P2_0 : Psub P2 X.eq X P2
  H : P3 = P2)
  H0 : (P3, P') -> False
  H0 : P2 -> False
  H1 : forall a : elt,
        In a (PX.eq_bool P'1 P'2 eqx (Pexpr P2_0 P'2)) -> PimpX M) H0 (In a (Pexpr P2_0 P'2)) -> PimpX M) H0 (In a P  P3)
  ============================
   (1) < l')


Debug: Going to execute:
<ltac_plugin::clear@0> $1


TcDebug (0) > 
Goal:
  
  E : Type
  P : elt -> bool
  P' : Proper (E.eq ==> Proper) P'
  P2L : Pol -> Prop
  P'1 : Pol -> Pol
  P2R : Pol
  P2R_of_positive : P2, P2, P'2, P2, P2, P1, P'2, P2, P1, P'2, P2, P2, (P3, P3)
  P1 : Pol
  l : list (X.t * P')
  y : elt
  Padd_P : Psub P1 x (PX.eq_PX Padd P2 P2) l
  P2_0 : Psub P2 X.eq X P2
  H : P3 = P2)
  H0 : (P3, P') -> False
  H0 : P2 -> False
  H1 : forall a : elt,
        In a (PX.eq_bool P'1 P'2 eqx (Pexpr P2_0 P'2)) -> PimpX M) H0 (In a (PExpr P2_0 P'2)) -> PimpX M) H0
  ============================
   (1) < l')


Debug: Going to execute
