======== SAMPLE 1 ========
 (e : clause) =>
       fun _ => let e1 := mkP t1 in
                     let e2 := mkP t2 in
                    (e1 + e2)%poly
  x : R
  y : R
  H : x < y
  ============================
   (x < y)


Debug:
Going to execute:
let rec TFV t fv :=
 let f :=
  match Cst t with
  | NotConstant =>
      match t with
      | rO => fun _ => fv
      | rI => fun _ => fv
      | add ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t2 lemma)
      | mul ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t2 lemma)
      | sub ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t2 lemma)
      | opp ?t1 => fun _ => TFV t1 ltac:(TFV t1 lemma)
      | pow ?t1 ?n =>
          match CstPow n with
          | NotConstant => fun _ => AddFvTail t fv
          | _ => fun _ => TFV t1 ltac:(TFV t1 lemma)
          end
      | _ => fun _ => AddFvTail t fv
      end
  | _ => fun _ => fv
  end
 in
 f ltac:(())
in
TFV t fv


TcDebug (14) > 
Debug: Level 13: evaluation returns
<tactic closure>


Debug: Level 12: evaluation returns
<tactic closure>


Goal:
  
  R : Type
  rO : R
  rI : R
  rplus : R -> R -> R
  rtimes : R -> R -> R
  rminus : R -> R -> R
  ropp : R -> R
  req : R -> R -> Prop
  rle : R -> R -> Prop
  rlt : R -> R -> Prop
  sor : SOR 0 1 rplus rtimes rminus ropp req rle rlt
  n : R
  m : R
  ============================
   (m + - n == m + - n)


Debug: Going to execute:
let f :=
 match Cst t with
  | NotConstant =>
      match t with
      | rO => fun _ => fv
      | rI => fun _ => fv
      | add ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t2 lemma)
      | mul ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t2 lemma)
      | sub ?t1 ?t2 => fun _ => TFV t2 ltac:(TFV t2 lemma)
      | opp ?t1 => fun _ => TFV t1 ltac:(TFV t1 lemma)
      | pow ?t1 ?n =>
          match CstPow n with
          | NotConstant => fun _ => AddFvTail t fv
          | _ => fun _ => TFV t1 ltac:(TFV t1 lemma)
          end
      | _ => fun _ => AddFvTail t fv
      end
  | _ => fun _ => fv
  end
 in
 f ltac:(())


TcDebug (12) > 
Goal:
  
  R : Type
 
