======== SAMPLE 1 ========
  n : positive
  H : (x <=? fr :: nil)%list
  H' : forall n : positive, (Pos.to_nat n <= Pos.to_nat (Pos.max n (4 * k)))%nat
  Hd : (Pos.to_nat n <= Pos.to_nat (Pos.max n (4 * k)))%nat
  list_hyp := nil : list (Ring_polynom.PExpr Q * Ring_polynom.PExpr Q)
  list_hyp_norm := nil : list (Q * Ring_polynom.Mon * Ring_polynom.Pol Q)
  ring_lemma : forall (pe : Ring_polynom.PExpr Q) (npe : Ring_polynom.Pol Q),
              Ring_polynom.norm_subst 0 1 Qplus Qmult Qminus Qopp Qeq_bool
                (triv_div 0 1 Qeq_bool) ring_subst_niter list_hyp_norm pe =
              npe ->
              (Ring_polynom.PEeval 0 1 Qplus Qmult Qminus Qopp
                 (IDphi (R:=Q)) Z.of_N Qpower
                 (yn (Pos.to_nat n) :: yn (Pos.to_nat (Pos.max n (4 * k))) :: 1 # n :: nil) pe ==
               Ring_polynom.Pphi_pow 0 1 Qplus Qmult Qminus Qopp 0 1
                 Qeq_bool (IDphi (R:=Q)) Z.of_N Qpower
                 (get_sign_None (C:=Q))
                 (yn (Pos.to_nat n) :: yn (Pos.to_nat (Pos.max n (4 * k))) :: 1 # n :: nil) npe)%Q
  res := Ring_polynom.PX (Ring_polynom.Pc 1) 1
           (Ring_polynom.Pinj 1
              (Ring_polynom.PX (Ring_polynom.Pc (-1)) 1 (Ring_polynom.Pc 0)))
      : Ring_polynom.Pol Q
  res_eq : Ring_polynom.norm_subst 0 1 Qplus Qmult Qminus Qopp Qeq_bool
             (triv_div 0 1 Qeq_bool) ring_subst_niter list_hyp_norm
             (Ring_polynom.PEadd
                (Ring_polynom.PEadd (Ring_polynom.PEX Q 1)
                   (Ring_polynom.PEX Q 2))
                (Ring_polynom.PEsub
                    (Ring_polynom.PEopp (Ring_polynom.PEX Q 3))
                    (Ring_polynom.PEX Q 4)) = res
  thm : ((n # 1) - (1 # 2) + (2 # 3) == (n # 1)%Q
  ============================
   (/ n # 1 == / n # 1)%Q


Debug: Going to execute:
pose (nhyps := nft); assert (eqn : t = t')


TcDebug (0) > 
Goal:
  
   xn : nat -> Q
  limx : QCauchySeq xn Pos.to_nat

