======== SAMPLE 1 ========
check Q
       |- _ => t_reduce; t_solver
       end
| _ => idtac
end


TcDebug (1) > 
Goal:
  
  x : X.t
  e : D.t
  m1 : list (X.t * D.t)
  IHm1 : forall (Hm1 : Sorted (Raw.PX.ltk (elt:=D.t)) m1) (m2 : slist D.t),
        InA eqke (x, e) m1 -> InA eqke (x, e) (elements m2)
  H : InA eqke (x, e) m1
  H0 : X.eq x x2
  ============================
   (InA eqke (x, e) ((x, e) :: elements m2))


Debug: Going to execute:
<Coq.Init.Tauto.axioms_and_conj> flags X1


TcDebug (2) > 
Goal:
  
  x : X.t
  e : D.t
  m1 : list (X.t * D.t)
  IHm1 : forall (Hm1 : Sorted (Raw.PX.ltk (elt:=D.t)) m1) (m2 : slist D.t),
        InA eqke (x, e) m1 -> InA eqke (x, e) (elements m2)
  H : InA eqke (x, e) m1
  H0 : X.eq x x2
  ============================
   (InA eqke (x, e) ((x, e) :: elements m2))


Debug: Going to execute:
fun tauto_flags X1 => <tauto_plugin::is_unit_or_eq@0>


TcDebug (3) > 
Goal:
  
  x : X.t
  e : D.t
  m1 : list (X.t * D.t)
  IHm1 : forall (Hm1 : Sorted (Raw.PX.ltk (elt:=D.t)) m1) (m2 : slist D.t),
        InA eqke (x, e) m1 -> InA eqke (x, e) (elements m2)
  H : InA eqke (x, e) m1
  H0 : X.eq x x2
  ============================
   (InA eqke (x, e) ((x, e) :: elements m2))


Debug: Going to execute:
<tauto_plugin::is_unit_or_eq@0>


TcDebug (3) > 
Debug: Level 3: evaluation returns
<tactic closure>


Goal:
  
  x : X.t
  e : D.t
  m1 : list (X.t * D.t)
  IHm1 : forall (Hm1 : Sorted (Raw.PX.ltk (elt:=D.t)) m1) (m2 : slist D.t),
        InA eqke (x, e) m1 -> InA eqke (x, e) (elements m2)
  H : InA eqke (x, e) m1
  H0 : X.eq x x2
  ============================
   (InA eqke (x, e) ((x, e) :: elements m2))


Debug:
Going to execute:
<Coq.Init.Tauto.axioms> flags ||
  match reverse goal with
  | id:(?X1 -> ?X2) -> ?X3
    |- _ =>
        cut X3;
         [ intro; clear id; t_tauto_intuit
         | cut (X1 -> X2);
            [ exact
            id
            | generalize (fun y : X2 =>
