======== SAMPLE 1 ========
) (fst p) + - gen_phiPOS1 + hsucc_lapply p0_1) 1 +
      gen_phiPOS1 + hsucc_lapply p0_2)))


Debug: Going to execute:
rewrite (ARmul_0_l ARth)


TcDebug (0) > 
Debug: Evaluated term: (ARmul_0_l ARth)

Debug: Level 0: Found no subterm matching "0 * ?r" in the current goal.

Debug: Level 0: Found no subterm matching "0 * ?r" in the current goal.

Goal:
  
  R : Type
  rO : R
  rI : R
  radd : R -> R -> R
  rmul : R -> R -> R
  rsub : R -> R -> R
  ropp : R -> R
  req : R -> R -> Prop
  Rsth : Equivalence req
  Reqe : ring_eq_ext radd rmul ropp req
  ARth : almost_ring_theory 0 1 radd rmul rsub ropp req
  C : Type
  cO : C
  cI : C
  cadd : C -> C -> C
  cmul : C -> C -> C
  csub : C -> C -> C
  copp : C -> C
  ceqb : C -> C -> bool
  phi : C -> R
  CRmorph : ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp
              ceqb phi
  Cpow : Type
  Cp_phi : N -> Cpow
  rpow : R -> Cpow -> R
  pow_th : power_theory 1 rmul req Cp_phi rpow
  cdiv : C -> C -> C * C
  div_th : div_theory req cadd cmul phi cdiv
  c0 : C
  p : positive
  M : Mon
  p0 : Pol
  H : Mon
  ============================
   (P @ (jump p0~1 l) + P @ (jump p0~0 l) ==
    P @ (jump p0~1 l) + -- (P @ (jump p0))".

Debug: Going to execute:
rewrite (ARmul_0_r Rsth ARth)


TcDebug (0) > 
Debug: Evaluated term: (ARmul_0_r Rsth ARth)

Debug: Level 0: Found no subterm matching "?r * 0" in the current goal.

Goal:
  
  R : Type
  rO : R
  rI : R
  radd : R -> R -> R
  rmul : R -> R -> R
  rsub : R -> R -> R
  ropp : R -> R
  req : R -> R -> Prop
  Rsth : Equivalence req
  Reqe : ring_eq_ext radd rmul ropp req
  ARth : almost_ring_theory 0 1 radd rmul rsub ropp req
  C : Type
  cO : C
  cI : C
  cadd : C -> C -> C
  cmul : C -> C -> C
  csub : C -> C -> C
  copp : C -> C
  ceqb : C -> C -> bool
  phi : C -> R
  CRmorph : ring_morph 0 1 radd rmul rsub ropp req cO cI cadd cmul csub copp
              ceqb phi
  Cpow : Type
  Cp_phi : N -> Cpow
  rpow : R -> Cpow -> R
  pow_th : power_theory 1 rmul req Cp_phi rpow
  cdiv : C -> C -> C * C
  div_th : div_theory req cadd cmul phi cdiv
  c0 : C
  p : positive
  M : Mon
  p0 : Pol
  H : Mon
  ============================
   (P @ (jump p0~1 l) + P @ (jump p0~1 l) == P
