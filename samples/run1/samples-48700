======== SAMPLE 1 ========
 x2 * Z.pos x2
             :: Z.pos x2 * Z.pos y2
  H1 : 0 <= Z.pos y2 * Z.pos x2
  H2 : 0 < z
  goal := False : Prop
  ============================
   Z.x * (Z.pos x2 * Z.pos y2) = (z1 * Z.pos x2 * Z.pos y2 * Z.pos z2)


Debug: Going to execute:
reflexivity


TcDebug (0) > 
Goal:
  
  x1 : Z
  x2 : positive
  y1 : Z
  y2 : positive
  z1 : Z
  z2 : positive
  t1 : Z
  t2 : positive
  H : x1 * Z.pos y2 < y1 * Z.pos x2
  H0 : z1 * Z.pos t2 <= t1 * Z.pos z2
  list_hyp := nil : list (Ring_polynom.PExpr Z * Ring_polynom.PExpr Z)
  list_hyp_norm := nil : list (Z * Ring_polynom.Mon * Ring_polynom.Pol Z)
  ring_lemma : forall (pe : Ring_polynom.PExpr Z) (npe : Ring_polynom.Pol Z),
               Ring_polynom.norm_subst 0 1 Z.add Z.mul Z.sub Z.opp Zeq_bool
                 Z.quotrem ring_subst_niter list_hyp_norm pe = npe ->
               Ring_polynom.PEeval 0 1 Z.add Z.mul Z.sub Z.opp 
                 (IDphi (R:=Z)) Z.of_N Z.pow
                 (x1
                  :: Z.pos x2
                       :: Z.pos y2 :: Z.pos t2 :: y1 :: t1 :: nil)
                    pe =
                 Ring_polynom.Pphi_pow 0 1 Z.add Z.mul Z.sub Z.opp 0 1 Zeq_bool
                   (IDphi (R:=Z)) Z.of_N Z.pow get_signZ
                  (x1
                   :: Z.pos x2
                         :: Z.pos y2 :: Z.pos t2 :: y1 :: t1 :: nil)
                     npe
  res := Ring_polynom.PX (Ring_polynom.Pc 1) 1 (Ring_polynom.Pc 0)
       : Ring_polynom.Pol Z
  res_eq : Ring_polynom.norm_subst 0 1 Z.add Z.mul Z.sub Z.opp Zeq_bool
             Z.quotrem ring_subst_niter list_hyp_norm 
             (Ring_polynom.PEX Z 1) = res
  thm : Ring_polynom.PEeval 0 1 Z.add Z.mul Z.sub Z.opp 
          (IDphi (R:=Z)) Z.of_N Z.pow
          (x1 :: y1 :: Z.pos x2 :: Z.pos y2 :: Z.pos z
